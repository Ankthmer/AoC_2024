from itertools import product

def part1(filename):
    #Read the antenna map from the input.
    with open(filename) as f:
        inp = [line.strip() for line in f]

    #Number of rows:
    n = len(inp)
    #Number of columns:
    m = len(inp[0])

    #A dictionary storing the locations of all different types of antennas.
    d = get_indexes(inp)

    #Return the number of antinodes.
    return len(get_nodes(d,n,m))

def part2(filename):
    #Read the antenna map from the input.
    with open(filename) as f:
        inp = [line.strip() for line in f]

    #Number of rows.
    n = len(inp)
    #Number of columns.
    m = len(inp[0])

    #A dictionary storing the locations of all different types of antennas.
    d = get_indexes(inp)

    #Return the number of antinodes.
    return len(get_nodes_part2(d,n,m))

def get_indexes(inp):
    '''Create a dictionary storing the locations of the different types of antennas on the map.'''
    d = {}

    for y , line in enumerate(inp):
        for x, col in enumerate(line):
            #If an antenna is found:
            if col != '.':
                #If its type is already stored in the dictionary:
                if col in d.keys():
                    #Add this antenna to your dictionary.
                    d[col].add((x, y))
                else:
                    #Otherwise, add the new type along with the new antenna.
                    d[col] = {(x, y)}
    return d

def get_nodes(d, n, m):
    '''
    Any two antennas of the same type generate two antinodes, one on either side at the same distance as the antennas are apart.
    Return the locations of all antinodes generated by the antennas.
    '''
    nodes = set()

    #For each type of antenna:
    for s in d.values():
        #For every pair of antennas in the Cartesian product of s.
        for ant1, ant2 in product(s, repeat = 2):
            #Discard pairs of identical antennas and keep only one copy of each combination.
            if ant1 >= ant2:
                continue

            #Extract the coordinates of the antennas.
            x1, y1 = ant1
            x2, y2 = ant2

            #Check that you have discarded the right copies.
            assert x1 <= x2

            #Components of the displacement vector between the two antennas.
            dx = x2 - x1
            dy = y2 - y1

            #Add all antinodes that remain within the map boundaries.
            if (-1 < x1 - dx < m) and (-1 < y1 - dy < n):
                nodes.add((x1 - dx, y1 - dy))
            if (-1 < x2 + dx < m) and (-1 < y2 + dy < n):
                nodes.add((x2 + dx, y2 + dy))

    return nodes

def get_nodes_part2(d, n, m):
    '''
    Any two antennas of the same type generate antinodes along their line, each spaced at the same distance as the antennas are apart.
    Return the locations of all antinodes generated by the antennas.
    '''
    nodes = set()

    #For every two antennas in the cartesian product of s.
    for s in d.values():
        #For every pair of antennas in the Cartesian product of s.
        for ant1, ant2 in product(s, repeat = 2):
            #Discard pairs of identical antennas and keep only one copy of each combination.
            if ant1 >= ant2:
                continue
            #Add the antinodes that are in the location of this two antennas.
            nodes.add(ant1)
            nodes.add(ant2)
            #Extract the coordinates of the antennas.
            x1, y1 = ant1
            x2, y2 = ant2

            #Check that you have discarded the right copies.
            assert x1 <= x2

            #Components of the displacement vector between the two antennas.
            dx = x2 - x1
            dy = y2 - y1

            #Add all antinodes that remain within the map boundaries.
            while (-1 < x1 - dx < m) and (-1 < y1 - dy < n):
                nodes.add((x1 - dx, y1 - dy))
                x1 -= dx
                y1 -= dy
            while (-1 < x2 + dx < m) and (-1 < y2 + dy < n):
                nodes.add((x2 + dx, y2 + dy))
                x2 += dx
                y2 += dy

    return nodes

if __name__ == "__main__":
    print(part1('input1.txt'))
    print(part1('input2.txt'))
    print(part2('input1.txt'))
    print(part2('input2.txt'))
